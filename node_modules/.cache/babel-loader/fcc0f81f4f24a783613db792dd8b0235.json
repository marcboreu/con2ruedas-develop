{"ast":null,"code":"import DOMPurify from 'dompurify';\n/**\n * Create pagination array.\n *\n * Example: [1, \"...\", 521, 522, 523, 524, 525, \"...\", 529]\n *\n * @param {int} currentPage Current page no.\n * @param {int} totalPages Count of total no of pages.\n * @return {Array} Array containing the indexes to be looped through to create pagination\n */\n\nexport const createPaginationArray = (currentPage, totalPages) => {\n  let loopableArray = [];\n  let countOfDotItems = 0; // If there is only one page, return an empty array.\n\n  if (1 === totalPages) {\n    return loopableArray;\n  }\n  /**\n   * Push the two index items before the current page.\n   */\n\n\n  if (0 < currentPage - 2) {\n    loopableArray.push(currentPage - 2);\n  }\n\n  if (0 < currentPage - 1) {\n    loopableArray.push(currentPage - 1);\n  } // Push the current page index item.\n\n\n  loopableArray.push(currentPage);\n  /**\n   * Push the two index items after the current page.\n   */\n\n  if (totalPages >= currentPage + 1) {\n    loopableArray.push(currentPage + 1);\n  }\n\n  if (totalPages >= currentPage + 2) {\n    loopableArray.push(currentPage + 2);\n  }\n  /**\n   * Push the '...' at the beginning of the array\n   * only if the difference of between the 1st and 2nd index item is greater than 1.\n   */\n\n\n  if (1 < loopableArray[0] - 1) {\n    loopableArray.unshift('...');\n    countOfDotItems += 1;\n  }\n  /**\n   * Push the '...' at the end of the array.\n   * only if the difference of between the last and 2nd last item is greater than 1.\n   * We remove the count of dot items from the array to get the actual indexes, while checking the condition.\n   */\n\n\n  if (1 < totalPages - loopableArray[loopableArray.length - (2 - countOfDotItems)]) {\n    loopableArray.push('...');\n  } // Push first index item in the array if it does not already exists.\n\n\n  if (-1 === loopableArray.indexOf(1)) {\n    loopableArray.unshift(1);\n  } // Push last index item in the array if it does not already exists.\n\n\n  if (-1 === loopableArray.indexOf(totalPages)) {\n    loopableArray.push(totalPages);\n  }\n\n  return loopableArray;\n};\n/**\n * Sanitize markup or text when used inside dangerouslysetInnerHTML\n *\n * @param {string} content Plain or html string.\n *\n * @return {string} Sanitized string\n */\n\nexport const sanitize = content => {\n  return process.browser ? DOMPurify.sanitize(content) : content;\n};","map":{"version":3,"sources":["/Users/marcboreu/Desktop/Webs - Develop/test app/con2ruedas/src/utils/functions.js"],"names":["DOMPurify","createPaginationArray","currentPage","totalPages","loopableArray","countOfDotItems","push","unshift","length","indexOf","sanitize","content","process","browser"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,qBAAqB,GAAG,CAAEC,WAAF,EAAeC,UAAf,KAA+B;AAEnE,MAAIC,aAAa,GAAK,EAAtB;AACA,MAAIC,eAAe,GAAG,CAAtB,CAHmE,CAKnE;;AACA,MAAK,MAAMF,UAAX,EAAwB;AACvB,WAAOC,aAAP;AACA;AAED;AACD;AACA;;;AACC,MAAK,IAAIF,WAAW,GAAG,CAAvB,EAA2B;AAC1BE,IAAAA,aAAa,CAACE,IAAd,CAAoBJ,WAAW,GAAG,CAAlC;AACA;;AAED,MAAK,IAAIA,WAAW,GAAG,CAAvB,EAA2B;AAC1BE,IAAAA,aAAa,CAACE,IAAd,CAAoBJ,WAAW,GAAG,CAAlC;AACA,GAnBkE,CAqBnE;;;AACAE,EAAAA,aAAa,CAACE,IAAd,CAAoBJ,WAApB;AAEA;AACD;AACA;;AACC,MAAKC,UAAU,IAAID,WAAW,GAAG,CAAjC,EAAqC;AACpCE,IAAAA,aAAa,CAACE,IAAd,CAAoBJ,WAAW,GAAG,CAAlC;AACA;;AAED,MAAKC,UAAU,IAAID,WAAW,GAAG,CAAjC,EAAqC;AACpCE,IAAAA,aAAa,CAACE,IAAd,CAAoBJ,WAAW,GAAG,CAAlC;AACA;AAED;AACD;AACA;AACA;;;AACC,MAAK,IAAIE,aAAa,CAAE,CAAF,CAAb,GAAqB,CAA9B,EAAkC;AACjCA,IAAAA,aAAa,CAACG,OAAd,CAAuB,KAAvB;AACAF,IAAAA,eAAe,IAAI,CAAnB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACC,MACC,IACAF,UAAU,GAAGC,aAAa,CAAEA,aAAa,CAACI,MAAd,IAAyB,IAAIH,eAA7B,CAAF,CAF3B,EAGE;AACDD,IAAAA,aAAa,CAACE,IAAd,CAAoB,KAApB;AACA,GAtDkE,CAwDnE;;;AACA,MAAK,CAAC,CAAD,KAAOF,aAAa,CAACK,OAAd,CAAuB,CAAvB,CAAZ,EAAyC;AACxCL,IAAAA,aAAa,CAACG,OAAd,CAAuB,CAAvB;AACA,GA3DkE,CA6DnE;;;AACA,MAAK,CAAC,CAAD,KAAOH,aAAa,CAACK,OAAd,CAAuBN,UAAvB,CAAZ,EAAkD;AACjDC,IAAAA,aAAa,CAACE,IAAd,CAAoBH,UAApB;AACA;;AAED,SAAOC,aAAP;AACA,CAnEM;AAqEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMM,QAAQ,GAAIC,OAAD,IAAa;AACpC,SAAOC,OAAO,CAACC,OAAR,GAAkBb,SAAS,CAACU,QAAV,CAAmBC,OAAnB,CAAlB,GAAgDA,OAAvD;AACA,CAFM","sourcesContent":["import DOMPurify from 'dompurify';\n\n/**\n * Create pagination array.\n *\n * Example: [1, \"...\", 521, 522, 523, 524, 525, \"...\", 529]\n *\n * @param {int} currentPage Current page no.\n * @param {int} totalPages Count of total no of pages.\n * @return {Array} Array containing the indexes to be looped through to create pagination\n */\nexport const createPaginationArray = ( currentPage, totalPages ) => {\n\n\tlet loopableArray   = [];\n\tlet countOfDotItems = 0;\n\n\t// If there is only one page, return an empty array.\n\tif ( 1 === totalPages ) {\n\t\treturn loopableArray;\n\t}\n\n\t/**\n\t * Push the two index items before the current page.\n\t */\n\tif ( 0 < currentPage - 2 ) {\n\t\tloopableArray.push( currentPage - 2 );\n\t}\n\n\tif ( 0 < currentPage - 1 ) {\n\t\tloopableArray.push( currentPage - 1 );\n\t}\n\n\t// Push the current page index item.\n\tloopableArray.push( currentPage );\n\n\t/**\n\t * Push the two index items after the current page.\n\t */\n\tif ( totalPages >= currentPage + 1 ) {\n\t\tloopableArray.push( currentPage + 1 );\n\t}\n\n\tif ( totalPages >= currentPage + 2 ) {\n\t\tloopableArray.push( currentPage + 2 );\n\t}\n\n\t/**\n\t * Push the '...' at the beginning of the array\n\t * only if the difference of between the 1st and 2nd index item is greater than 1.\n\t */\n\tif ( 1 < loopableArray[ 0 ] - 1 ) {\n\t\tloopableArray.unshift( '...' );\n\t\tcountOfDotItems += 1;\n\t}\n\n\t/**\n\t * Push the '...' at the end of the array.\n\t * only if the difference of between the last and 2nd last item is greater than 1.\n\t * We remove the count of dot items from the array to get the actual indexes, while checking the condition.\n\t */\n\tif (\n\t\t1 <\n\t\ttotalPages - loopableArray[ loopableArray.length - ( 2 - countOfDotItems ) ]\n\t) {\n\t\tloopableArray.push( '...' );\n\t}\n\n\t// Push first index item in the array if it does not already exists.\n\tif ( -1 === loopableArray.indexOf( 1 ) ) {\n\t\tloopableArray.unshift( 1 );\n\t}\n\n\t// Push last index item in the array if it does not already exists.\n\tif ( -1 === loopableArray.indexOf( totalPages ) ) {\n\t\tloopableArray.push( totalPages );\n\t}\n\n\treturn loopableArray;\n};\n\n/**\n * Sanitize markup or text when used inside dangerouslysetInnerHTML\n *\n * @param {string} content Plain or html string.\n *\n * @return {string} Sanitized string\n */\nexport const sanitize = (content) => {\n\treturn process.browser ? DOMPurify.sanitize(content) : content\n}\n"]},"metadata":{},"sourceType":"module"}